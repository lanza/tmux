#!/usr/bin/env python3

import argparse
import glob
import os
import signal
import subprocess
import sys
import tempfile
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

RED = "\033[31m"
GREEN = "\033[32m"
DIM = "\033[2m"
RESET = "\033[0m"

print_lock = threading.Lock()

def kill_lingering_servers(sockdir):
    """Kill any tmux servers left behind by a test."""
    tmux = os.path.join(os.path.dirname(os.path.abspath(__file__)), "tmux")
    env = {**os.environ, "TMUX_TMPDIR": sockdir}
    for sock in ("test", "test2"):
        subprocess.run(
            [tmux, "-L" + sock, "kill-server"],
            env=env, capture_output=True,
        )

def run_test(t, sockdir, label, strict):
    env = {**os.environ, "TMUX_TMPDIR": sockdir}
    env.pop("TMUX", None)
    env.pop("TMUX_PANE", None)
    if strict:
        env["STRICT"] = "1"
    t_start = time.time()
    result = subprocess.run(["sh", t], env=env, capture_output=True)
    elapsed = time.time() - t_start
    output = (result.stdout + result.stderr).decode(errors="replace")

    kill_lingering_servers(sockdir)

    color = GREEN if result.returncode == 0 else RED
    status = "PASS" if result.returncode == 0 else "FAIL"

    with print_lock:
        print(f"{color}{status}{RESET} {label} {DIM}({elapsed:.3f}s){RESET}")
        if output:
            for line in output.splitlines():
                print(f"  {line}")

    return result.returncode

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-l", "--loop", type=int)
    parser.add_argument("-p", "--parallel", action="store_true")
    parser.add_argument("-f", "--filter", type=str, help="only run tests whose filename contains this string")
    parser.add_argument("-s", "--strict", action="store_true", help="treat XFAIL as FAIL")
    args = parser.parse_args()

    if subprocess.run(["make", "-j18"]).returncode != 0:
        sys.exit(1)

    os.chdir("regress")
    tests = sorted(glob.glob("*.sh"))
    if args.filter:
        tests = [t for t in tests if args.filter in t]
    iterations = args.loop or 1

    passed = 0
    failed = 0
    suite_start = time.time()

    with tempfile.TemporaryDirectory() as tmpdir:
        if args.parallel:
            futures = []
            with ThreadPoolExecutor() as executor:
                for t in tests:
                    for i in range(iterations):
                        sockdir = os.path.join(tmpdir, f"sock_{t}_{i}")
                        os.makedirs(sockdir)
                        loop_info = f" [run {i+1}/{iterations}]" if args.loop else ""
                        label = f"{t}{loop_info}"
                        futures.append(executor.submit(run_test, t, sockdir, label, args.strict))
            for future in futures:
                if future.result() == 0:
                    passed += 1
                else:
                    failed += 1
        else:
            for t in tests:
                for i in range(iterations):
                    sockdir = os.path.join(tmpdir, f"sock_{t}_{i}")
                    os.makedirs(sockdir)
                    loop_info = f" [run {i+1}/{iterations}]" if args.loop else ""
                    label = f"{t}{loop_info}"
                    rc = run_test(t, sockdir, label, args.strict)
                    if rc == 0:
                        passed += 1
                    else:
                        failed += 1
                    if rc != 0 and args.loop:
                        break

    suite_elapsed = int(time.time() - suite_start)
    total = passed + failed

    summary = f"\n{GREEN}{passed} passed{RESET}"
    if failed > 0:
        summary += f", {RED}{failed} failed{RESET}"
    summary += f" (out of {total}) in {suite_elapsed}s"
    print(summary)

    sys.exit(0 if failed == 0 else 1)

if __name__ == "__main__":
    signal.signal(signal.SIGINT, lambda *_: os._exit(130))
    main()
